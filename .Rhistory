e.start
e.end
e.start
e.end
A
## Define a matrix A[[k]] choosing the paths from k to other vertices
idx.e <- matrix(0, nrow=d, ncol=d)
idx.e[ends.mat] = 1:e
idx.e
idx.e + t(idx.e)
k <- 1
h <- 4
path
length(path)
path(-4)
path[-4]
path[-1]
cbind(c(1,2,3), c(2, 3, 4))
idx.e
simu_tree_old <- function(tree, model, method, n=1, Gamma=NULL, theta=NULL,
alpha.mat=NULL, loc=1, scale=1, shape=1) {
require("igraph")
adj =  as.matrix(as_adj(tree))
d <- nrow(adj)
e <- ecount(tree)
ends.mat = ends(tree, E(tree))
stopifnot(model %in% c("logistic", "HR", "dirichlet"))
stopifnot((d==round(d)) & (d>=1))
stopifnot((n==round(n)) & (n>=1))
if (length(loc)  ==1) loc   <- rep(loc  , times=d)
if (length(scale)==1) scale <- rep(scale, times=d)
if (length(shape)==1) shape <- rep(shape, times=d)
stopifnot(all(scale>1e-12))
if (model=="logistic") {
stopifnot(1e-12 < theta & theta < 1 - 1e-12)
} else if (model=="HR") {
par.vec = Gamma[ends.mat]
} else if (model=="dirichlet") {
stopifnot(nrow(alpha.mat) == d-1 & ncol(alpha.mat) == 2)
}
browser()
## Define a matrix A[[k]] choosing the paths from k to other vertices
idx.e <- matrix(0, nrow=d, ncol=d)
idx.e[ends.mat] = 1:e
idx.e[lower.tri(idx.e)] <- 0
idx.e = idx.e + t(idx.e) # @Sesbastian: this I think causes problems
A <- e.start <- e.end <- list() #e.start[[k]][h] gives the index (1 or 2)
# of the starting node in the h edge in the tree rooted at k
for (k in 1:d) {
A[[k]] <- matrix(0, nrow=d, ncol=e)
e.start[[k]] = e.end[[k]] = numeric(e)
short.paths <- shortest_paths(tree, from = k, to=1:d)
for(h in 1:d){
path = short.paths$vpath[[h]]
idx.tmp = idx.e[cbind(path[-length(path)], path[-1])]
A[[k]][h,idx.tmp] <- 1
e.start[[k]][idx.tmp] =
apply(ends.mat[idx.tmp,] == matrix(path[-length(path)],
nrow = length(idx.tmp), ncol=2),
MARGIN=1,
FUN = function(x) which(x==TRUE)) #path[-length(path)]
e.end[[k]][idx.tmp] =
apply(ends.mat[idx.tmp,] == matrix(path[-1],
nrow = length(idx.tmp), ncol=2),
MARGIN=1, FUN = function(x) which(x==TRUE))  #path[-1]
}
}
if(method=="mpareto")
{
counter <- 0
res <- numeric(0)
n.total <- 0
while (n.total < n) {
counter <- counter + 1
shift <- sample(1:d, n, replace=TRUE)
for(k in 1:d){
n.k <- sum(shift==k)
if(n.k>0){
proc <- switch(model,
"HR" = simu_px_tree_HR(n=n.k, G.vec=par.vec, A = A[[k]]),
"logistic"     = simu_px_tree_logistic(n=n.k, idx=k, nb.edges=e, theta=theta, A=A),
"dirichlet"     = simu_px_tree_dirichlet(n=n.k, alpha.start = alpha.mat[cbind(1:e, e.start[[k]])], #@Sebastian: here, the matrix cbind(1:e, e.start[[k]]) looks strange
alpha.end = alpha.mat[cbind(1:e, e.end[[k]])], A=A[[k]])  #@Sebastian: here, the matrix cbind(1:e, e.start[[k]]) looks strange
)
stopifnot(dim(proc)==c(n.k, d))
proc <- proc/rowSums(proc) / (1-runif(nrow(proc)))
idx.sim <- which(apply(proc,1,max) > 1)
res <- rbind(res, proc[idx.sim,])
n.total <- nrow(res)
}
}
}
}else if(method=="maxstable"){
counter <- rep(0, times=n)
res <- matrix(0, nrow=n, ncol=d)
for (k in 1:d) {
poisson <- rexp(n)
while (any(1/poisson > res[,k])) {
ind <- (1/poisson > res[,k])
n.ind <- sum(ind)
idx <- (1:n)[ind]
counter[ind] <- counter[ind] + 1
proc <- switch(model,
"HR" = simu_px_tree_HR(n=n.ind, G.vec=par.vec, A = A[[k]]),
"logistic"     = simu_px_tree_logistic(n=n.ind, idx=k, nb.edges=e, theta=theta, A=A),
"dirichlet"     = simu_px_tree_dirichlet(n=n.ind, alpha.start = alpha.mat[cbind(1:e, e.start[[k]])],
alpha.end = alpha.mat[cbind(1:e, e.end[[k]])], A=A[[k]])
)
stopifnot(dim(proc)==c(n.ind, d))
if (k==1) {
ind.upd <- rep(TRUE, times=n.ind)
} else {
ind.upd <- sapply(1:n.ind, function(i)
all(1/poisson[idx[i]]*proc[i,1:(k-1)] <= res[idx[i],1:(k-1)]))
}
if (any(ind.upd)) {
idx.upd <- idx[ind.upd]
res[idx.upd,] <- pmax(res[idx.upd,], 1/poisson[idx.upd]*proc[ind.upd,])
}
poisson[ind] <- poisson[ind] + rexp(n.ind)
}
}
res <- sapply(1:d, function(i) {
if (abs(shape[i]<1e-12)) {
return(log(res[,i])*scale[i] + loc[i])
} else {
return(1/shape[i]*(res[,i]^shape[i]-1)*scale[i] + loc[i])
}
})
}
return(list(res=res[sample(1:nrow(res), n, replace=FALSE),], counter=counter))
}
simu_tree_old(treee, "HR", "mpareto", n = 3, Gamma = G)
idx.e
ends.mat
A
A
path
e.start
e.end
e.start
path
e.start
e.end
e.start
e.start
k
A
e.start
e.end
h
h
proc
simu_tree_old(treee, "dirichlet", "mpareto", n = 3, alpha.mat = alpha)
cbind(1:e, e.start[[k]])
alpha.mat
k
e.start
e.start[[1]]
1:e
alpha.mat[cbind(1:e, e.start[[k]])]
cbind(1:e, e.start[[k]])
simu_tree_old <- function(tree, model, method, n=1, Gamma=NULL, theta=NULL,
alpha.mat=NULL, loc=1, scale=1, shape=1) {
require("igraph")
adj =  as.matrix(as_adj(tree))
d <- nrow(adj)
e <- ecount(tree)
ends.mat = ends(tree, E(tree))
stopifnot(model %in% c("logistic", "HR", "dirichlet"))
stopifnot((d==round(d)) & (d>=1))
stopifnot((n==round(n)) & (n>=1))
if (length(loc)  ==1) loc   <- rep(loc  , times=d)
if (length(scale)==1) scale <- rep(scale, times=d)
if (length(shape)==1) shape <- rep(shape, times=d)
stopifnot(all(scale>1e-12))
if (model=="logistic") {
stopifnot(1e-12 < theta & theta < 1 - 1e-12)
} else if (model=="HR") {
par.vec = Gamma[ends.mat]
} else if (model=="dirichlet") {
stopifnot(nrow(alpha.mat) == d-1 & ncol(alpha.mat) == 2)
}
browser()
## Define a matrix A[[k]] choosing the paths from k to other vertices
idx.e <- matrix(0, nrow=d, ncol=d)
idx.e[ends.mat] = 1:e
idx.e[lower.tri(idx.e)] <- 0
idx.e = idx.e + t(idx.e) # @Sesbastian: this I think causes problems
A <- e.start <- e.end <- list() #e.start[[k]][h] gives the index (1 or 2)
# of the starting node in the h edge in the tree rooted at k
for (k in 1:d) {
A[[k]] <- matrix(0, nrow=d, ncol=e)
e.start[[k]] = e.end[[k]] = numeric(e)
short.paths <- shortest_paths(tree, from = k, to=1:d)
for(h in 1:d){
path = short.paths$vpath[[h]]
idx.tmp = idx.e[cbind(path[-length(path)], path[-1])]
A[[k]][h,idx.tmp] <- 1
e.start[[k]][idx.tmp] =
apply(ends.mat[idx.tmp,] == matrix(path[-length(path)],
nrow = length(idx.tmp), ncol=2),
MARGIN=1,
FUN = function(x) which(x==TRUE)) #path[-length(path)]
e.end[[k]][idx.tmp] =
apply(ends.mat[idx.tmp,] == matrix(path[-1],
nrow = length(idx.tmp), ncol=2),
MARGIN=1, FUN = function(x) which(x==TRUE))  #path[-1]
}
}
if(method=="mpareto")
{
counter <- 0
res <- numeric(0)
n.total <- 0
while (n.total < n) {
counter <- counter + 1
shift <- sample(1:d, n, replace=TRUE)
for(k in 1:d){
n.k <- sum(shift==k)
if(n.k>0){
proc <- switch(model,
"HR" = simu_px_tree_HR(n=n.k, G.vec=par.vec, A = A[[k]]),
"logistic"     = simu_px_tree_logistic(n=n.k, idx=k, nb.edges=e, theta=theta, A=A),
"dirichlet"     = simu_px_tree_dirichlet(n=n.k, alpha.start = alpha.mat[cbind(1:e, e.start[[k]])], #@Sebastian: here, the matrix cbind(1:e, e.start[[k]]) looks strange
alpha.end = alpha.mat[cbind(1:e, e.end[[k]])], A=A[[k]])  #@Sebastian: here, the matrix cbind(1:e, e.start[[k]]) looks strange
)
stopifnot(dim(proc)==c(n.k, d))
proc <- proc/rowSums(proc) / (1-runif(nrow(proc)))
idx.sim <- which(apply(proc,1,max) > 1)
res <- rbind(res, proc[idx.sim,])
n.total <- nrow(res)
}
}
}
}else if(method=="maxstable"){
counter <- rep(0, times=n)
res <- matrix(0, nrow=n, ncol=d)
for (k in 1:d) {
poisson <- rexp(n)
while (any(1/poisson > res[,k])) {
ind <- (1/poisson > res[,k])
n.ind <- sum(ind)
idx <- (1:n)[ind]
counter[ind] <- counter[ind] + 1
proc <- switch(model,
"HR" = simu_px_tree_HR(n=n.ind, G.vec=par.vec, A = A[[k]]),
"logistic"     = simu_px_tree_logistic(n=n.ind, idx=k, nb.edges=e, theta=theta, A=A),
"dirichlet"     = simu_px_tree_dirichlet(n=n.ind, alpha.start = alpha.mat[cbind(1:e, e.start[[k]])],
alpha.end = alpha.mat[cbind(1:e, e.end[[k]])], A=A[[k]])
)
stopifnot(dim(proc)==c(n.ind, d))
if (k==1) {
ind.upd <- rep(TRUE, times=n.ind)
} else {
ind.upd <- sapply(1:n.ind, function(i)
all(1/poisson[idx[i]]*proc[i,1:(k-1)] <= res[idx[i],1:(k-1)]))
}
if (any(ind.upd)) {
idx.upd <- idx[ind.upd]
res[idx.upd,] <- pmax(res[idx.upd,], 1/poisson[idx.upd]*proc[ind.upd,])
}
poisson[ind] <- poisson[ind] + rexp(n.ind)
}
}
res <- sapply(1:d, function(i) {
if (abs(shape[i]<1e-12)) {
return(log(res[,i])*scale[i] + loc[i])
} else {
return(1/shape[i]*(res[,i]^shape[i]-1)*scale[i] + loc[i])
}
})
}
return(list(res=res[sample(1:nrow(res), n, replace=FALSE),], counter=counter))
}
G <- matrix(nrow = d, ncol = d)
for (i in 1:d){
for (j in 1:d){
G[i, j] = 2 * abs(i - j)
}
}
G
Gamma2Graph(G)
simu_tree_old(treee, "HR", "mpareto", n = 3, Gamma = G)
ends.mat
idx.e <- matrix(0, nrow=d, ncol=d)
idx.e[ends.mat] = 1:e
idx.e
ends.mat
idx.e
short.paths
path
ends.mat
idx.tmp
A
h
ends.mat
idx.e
simu_tree_old <- function(tree, model, method, n=1, Gamma=NULL, theta=NULL,
alpha.mat=NULL, loc=1, scale=1, shape=1) {
require("igraph")
adj =  as.matrix(as_adj(tree))
d <- nrow(adj)
e <- ecount(tree)
ends.mat = ends(tree, E(tree))
stopifnot(model %in% c("logistic", "HR", "dirichlet"))
stopifnot((d==round(d)) & (d>=1))
stopifnot((n==round(n)) & (n>=1))
if (length(loc)  ==1) loc   <- rep(loc  , times=d)
if (length(scale)==1) scale <- rep(scale, times=d)
if (length(shape)==1) shape <- rep(shape, times=d)
stopifnot(all(scale>1e-12))
if (model=="logistic") {
stopifnot(1e-12 < theta & theta < 1 - 1e-12)
} else if (model=="HR") {
par.vec = Gamma[ends.mat]
} else if (model=="dirichlet") {
stopifnot(nrow(alpha.mat) == d-1 & ncol(alpha.mat) == 2)
}
browser()
## Define a matrix A[[k]] choosing the paths from k to other vertices
idx.e <- matrix(0, nrow=d, ncol=d)
idx.e[ends.mat] = 1:e
# idx.e[lower.tri(idx.e)] <- 0
idx.e = idx.e + t(idx.e) # @Sesbastian: this I think causes problems
A <- e.start <- e.end <- list() #e.start[[k]][h] gives the index (1 or 2)
# of the starting node in the h edge in the tree rooted at k
for (k in 1:d) {
A[[k]] <- matrix(0, nrow=d, ncol=e)
e.start[[k]] = e.end[[k]] = numeric(e)
short.paths <- shortest_paths(tree, from = k, to=1:d)
for(h in 1:d){
path = short.paths$vpath[[h]]
idx.tmp = idx.e[cbind(path[-length(path)], path[-1])]
A[[k]][h,idx.tmp] <- 1
e.start[[k]][idx.tmp] =
apply(ends.mat[idx.tmp,] == matrix(path[-length(path)],
nrow = length(idx.tmp), ncol=2),
MARGIN=1,
FUN = function(x) which(x==TRUE)) #path[-length(path)]
e.end[[k]][idx.tmp] =
apply(ends.mat[idx.tmp,] == matrix(path[-1],
nrow = length(idx.tmp), ncol=2),
MARGIN=1, FUN = function(x) which(x==TRUE))  #path[-1]
}
}
if(method=="mpareto")
{
counter <- 0
res <- numeric(0)
n.total <- 0
while (n.total < n) {
counter <- counter + 1
shift <- sample(1:d, n, replace=TRUE)
for(k in 1:d){
n.k <- sum(shift==k)
if(n.k>0){
proc <- switch(model,
"HR" = simu_px_tree_HR(n=n.k, G.vec=par.vec, A = A[[k]]),
"logistic"     = simu_px_tree_logistic(n=n.k, idx=k, nb.edges=e, theta=theta, A=A),
"dirichlet"     = simu_px_tree_dirichlet(n=n.k, alpha.start = alpha.mat[cbind(1:e, e.start[[k]])], #@Sebastian: here, the matrix cbind(1:e, e.start[[k]]) looks strange
alpha.end = alpha.mat[cbind(1:e, e.end[[k]])], A=A[[k]])  #@Sebastian: here, the matrix cbind(1:e, e.start[[k]]) looks strange
)
stopifnot(dim(proc)==c(n.k, d))
proc <- proc/rowSums(proc) / (1-runif(nrow(proc)))
idx.sim <- which(apply(proc,1,max) > 1)
res <- rbind(res, proc[idx.sim,])
n.total <- nrow(res)
}
}
}
}else if(method=="maxstable"){
counter <- rep(0, times=n)
res <- matrix(0, nrow=n, ncol=d)
for (k in 1:d) {
poisson <- rexp(n)
while (any(1/poisson > res[,k])) {
ind <- (1/poisson > res[,k])
n.ind <- sum(ind)
idx <- (1:n)[ind]
counter[ind] <- counter[ind] + 1
proc <- switch(model,
"HR" = simu_px_tree_HR(n=n.ind, G.vec=par.vec, A = A[[k]]),
"logistic"     = simu_px_tree_logistic(n=n.ind, idx=k, nb.edges=e, theta=theta, A=A),
"dirichlet"     = simu_px_tree_dirichlet(n=n.ind, alpha.start = alpha.mat[cbind(1:e, e.start[[k]])],
alpha.end = alpha.mat[cbind(1:e, e.end[[k]])], A=A[[k]])
)
stopifnot(dim(proc)==c(n.ind, d))
if (k==1) {
ind.upd <- rep(TRUE, times=n.ind)
} else {
ind.upd <- sapply(1:n.ind, function(i)
all(1/poisson[idx[i]]*proc[i,1:(k-1)] <= res[idx[i],1:(k-1)]))
}
if (any(ind.upd)) {
idx.upd <- idx[ind.upd]
res[idx.upd,] <- pmax(res[idx.upd,], 1/poisson[idx.upd]*proc[ind.upd,])
}
poisson[ind] <- poisson[ind] + rexp(n.ind)
}
}
res <- sapply(1:d, function(i) {
if (abs(shape[i]<1e-12)) {
return(log(res[,i])*scale[i] + loc[i])
} else {
return(1/shape[i]*(res[,i]^shape[i]-1)*scale[i] + loc[i])
}
})
}
return(list(res=res[sample(1:nrow(res), n, replace=FALSE),], counter=counter))
}
simu_tree_old(treee, "HR", "mpareto", n = 3, Gamma = G)
idx.e
idx.e <- matrix(0, nrow=d, ncol=d)
idx.e[ends.mat] = 1:e
idx.e
k
h
path
A
ends.mat[1, ]
e.start[[k]]
t(ends.mat)
e
e.end
k
path
A
t(ends.mat)
e.start
t(ends.mat)
e.end
k
alpha.mat
alpha <- matrix(runif((d - 1) * 2), ncol = 2)
alpha
alpha.start = alpha.mat[cbind(1:e, e.start[[k]])]
cbind(1:e, e.start[[k]])
alpha.mat
alpha.mat <- alpha
alpha.start = alpha.mat[cbind(1:e, e.start[[k]])]
alpha.mat
cbind(1:e, e.start[[k]])
ecount(tree)
treee
is_directed(treee)
tree2 <- undirected_graph(treee)
tree2
## Create tree
treee <- igraph::graph_from_adjacency_matrix(rbind(c(0, 1, 0, 0),
c(1, 0, 1, 0),
c(0, 1, 0, 1),
c(0, 0, 1, 0)))
treee
?undirected_graph()
## Create tree
treee <- igraph::graph_from_adjacency_matrix(rbind(c(0, 1, 0, 0),
c(1, 0, 1, 0),
c(0, 1, 0, 1),
c(0, 0, 1, 0)),
mode = "undirected")
tree()
treee
igraph::plot.igraph(treee)
simu_tree_old(treee, "HR", "mpareto", n = 3, Gamma = G)
e
ends.ma
ends.mat
idx.e
idx.e
idx.e
ends.mat
k
h
e.start[[1]]
e.start
t(ends.mat)
e.ends
e.end
path
e.start[[2]]
t(ends.mat)
e.ends
e.end[[2]]
A
par.vec
G.vec <- par.vec
rnorm(length(G.vec)*n
)
matrix(rnorm(length(G.vec)*n, mean= -G.vec/2, sd=sqrt(G.vec))
)
matrix(rnorm(length(G.vec)*n, mean= -G.vec/2, sd=sqrt(G.vec)), ncol=n)
n <- 4
matrix(rnorm(length(G.vec)*n, mean= -G.vec/2, sd=sqrt(G.vec)), ncol=n)
A
A[[1]]
matrix(rnorm(length(G.vec)*n, mean= -G.vec/2, sd=sqrt(G.vec)), ncol=n)
simu_tree_old(treee, "dirichlet", "mpareto", n = 3, alpha.mat = alpha)
idx.e
?cycle
igraph::is
proc
proc
devtools::load_all(".")
?rmpareto_tree()
?rmpareto()
?rmstable_tree()
?rmstable_tree()
?rmparet_tree()
?rmpareto_tree()
?rmpareto()
exit
