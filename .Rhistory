rmpareto("HR", 4, par = variogram, no.simu = 1)
rmpareto("HR", 4, par = variogram, no.simu = 1)
rmpareto("HR", 4, par = variogram, no.simu = 1)
rmpareto("HR", 4, par = variogram, no.simu = 1)
sample(1:4, 10, replace = T)
rmpareto("HR", 3, par = variogram)
rmpareto("HR", 4, par = variogram)
rmpareto("HR", 4, par = variogram)
set.seed(1991)
rmpareto("HR", 4, par = variogram)
set.seed(1991)
debug(rmpareto)
rmpareto("HR", 4, par = variogram)
chol(cov.mat - 1e3)
shift
n.k
res
res
idx.sim
proc
apply(proc, 1, max)
shift
proc
proc
idx.sim
n.total
undebug(rmpareto)
rmpareto("HR", 4, no.simu = 43, par = variogram)
debug(rmpareto)
rmpareto("HR", 4, no.simu = 43, par = variogram)
shift
n.k
proc
n.k
d
proc
res
n.k
res
proc
res
res
shift
n.k
shift
n.total
no.simu
res
shift
n.k
idx.sim
res
n.k
res
no.simu
nrow(resetClass())
nrow(res)
sample(1:47, size = 43)
graphicalExtremes::rmpareto()
?graphicalExtremes::rmpareto()
?graphicalExtremes::rmpareto()
a = 2
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::test()
devtools::load_all(".")
library(graphicalExtremes)
devtools::load_all(".")
devtools::load_all(".")
library(igraph)
Gamma2Graph(G)
## 1. fully connected graph
G = cbind(c(0,2,2,2), c(2,0,2,2), c(2,2,0,2), c(2,2,2,0))
Gamma2Graph(G)
## 2. star-shaped graph
G = cbind(c(0,1,1,1), c(1,0,2,2), c(1,2,0,2), c(1,2,2,0))
Gamma2Graph(G)
## 3. Non-decomposable graph
G = cbind(c(0,1.5,1.5,2), c(1.5,0,2,1.5), c(1.5,2,0,1.5), c(2,1.5,1.5,0))
Gamma2Graph(G)
Gamma2Sigma(G)
Gamma2Sigma(G, full = T)
g
G
G
Gamma2Sigma(G, full = T)
?graphicalExtremes::rmpareto()
rmpareto(model = "HR", no.simu = 1, d = 3, par = G)
rmpareto(model = "HR", no.simu = 1, d = 4, par = G)
rmpareto(model = "logistic", no.simu = 1, d = 4, par = .4)
rmpareto(model = "logistic", no.simu = 1, d = 4, par = 1)
rmpareto(model = "logistic", no.simu = 1, d = 4, par = 0)
rmpareto(model = "neglogistic", no.simu = 1, d = 4, par = 0)
rmpareto(model = "neglogistic", no.simu = 1, d = 4, par = 1.3)
rmpareto(model = "neglogistic", no.simu = 1, d = 4, par = 1)
cov.mat <- Gamma2Sigma(Gamma, k=1, full=FALSE)
Gamma <- G
cov.mat <- Gamma2Sigma(Gamma, k=1, full=FALSE)
cov.mat
chol.mat <- matrix(0,d,d)
chol.mat
chol.mat <- matrix(0,d,d)
d <- 4
chol.mat
chol.mat[-1,-1] <- chol(cov.mat) ## add warning if cannot chol()
chol.mat
cov.mat <- Gamma2Sigma(Gamma, k=1, full=FALSE)
d
chol.mat <- matrix(0,d,d)
chol.mat
chol.mat[-1,-1] <- chol(cov.mat) ## add warning if cannot chol()
chol.mat
devtools::load_all(".")
#' variogram, if \code{model = HR}.
#' }
#' @return List. The list is made of:
#' \itemize{
#' \item \code{res} Numeric matrix of size \eqn{no.simu \times d}{no.simu x d}.
#' The simulated multivariate Pareto data.
#' \item \code{counter} Positive integer. The number of times needed to sweep
#' over the \code{d} variables to simulate \code{no.simul} multivariate
#' observations.
#' }
rmpareto <- function(model, d, no.simu=1, par) {
stopifnot((d==round(d)) & (d>=1))
stopifnot((no.simu==round(no.simu)) & (no.simu>=1))
stopifnot(model %in% c("HR", "logistic", "neglogistic", "dirichlet"))
if (model=="HR") {
stopifnot(is.matrix(par))
Gamma = par
stopifnot(nrow(Gamma) == d & ncol(Gamma) == d)
cov.mat <- Gamma2Sigma(Gamma, k=1, full=FALSE)
chol.mat <- matrix(0,d,d)
chol.mat[-1,-1] <- chol(cov.mat)
# !!! add error if cannot chol()
# !!! put here the trend and save it as a matrix (each row is one variable)
} else if (model=="logistic") {
stopifnot(length(par) == 1 & 1e-12 < par & par < 1 - 1e-12)
theta = par
} else if (model=="neglogistic") {
stopifnot(par > 1e-12)
theta = par
} else if (model=="dirichlet") {
alpha = par
stopifnot(length(alpha) == d)
stopifnot(all(alpha>1e-12))
}
counter <- 0
res <- numeric(0)
n.total <- 0
while (n.total < no.simu){
counter <- counter + 1
shift <- sample(1:d, no.simu, replace=TRUE)
for(k in 1:d){
if (model == "HR") {
trend <- sapply(1:d, function(j) Gamma[j,k]/2)
}
n.k <- sum(shift==k)
if(n.k>0){
proc <- switch(model,
"HR"           = simu_px_HR(no.simu=n.k, idx=k, trend=trend, chol.mat=chol.mat),
"logistic"     = simu_px_logistic(no.simu=n.k, idx=k, N=d, theta=theta),
"neglogistic"  = simu_px_neglogistic(no.simu=n.k, idx=k, N=d, theta=theta),
"dirichlet"    = simu_px_dirichlet(no.simu=n.k, idx=k, N=d, alpha=alpha)
)
stopifnot(dim(proc)==c(n.k, d))
proc <- proc/rowSums(proc) / (1-runif(nrow(proc)))
idx.sim <- which(apply(proc,1,max) > 1)
res <- rbind(res, proc[idx.sim,])
n.total <- nrow(res)
}
}
}
return(list(res=res[sample(1:nrow(res), no.simu, replace=FALSE),],
counter=counter))
}
rmpareto("hf")
rmpareto("hf", d = 1.2)
runif()
rnorm()
rnorm(
rnorm
runif
simu_px_tree_HR
simu_px_tree_HR
rexp(no.simu)
no.simu <- 1
poisson <- rexp(no.simu)
rexp(no.simu)
?stopifnot
#' Simulates HR extremal functions
#'
#' Simulate the Huessler-Reiss extremal functions
#'
#' @inheritParams rmpareto
#' @param idx Integer. Index corresponding to the variable over which
#' the extremal function is simulated.
#' @param trend Numeric. Trend corresponding to the variable \code{idx}.
#' @param chol_mat Numeric matrix. Cholesky decomposition of the desired
#' covariance matrix.
simu_px_HR <- function(n, idx, d, trend, chol_mat) {
# check arguments
if(length(idx)!=1) stop("Argument idx must be a scalar.")
# function body
d <- nrow(chol_mat)
proc <- t(chol_mat)%*%matrix(rnorm(d*n), ncol=n) - trend
proc <- exp(t(proc) - proc[idx,])
return(proc)
}
## 3. Non-decomposable graph
G = cbind(c(0,1.5,1.5,2), c(1.5,0,2,1.5), c(1.5,2,0,1.5), c(2,1.5,1.5,0))
debug(simu_px_HR)
#' @return List. The list is made of:
#' \itemize{
#' \item \code{res} Numeric matrix of size \eqn{n \times d}{n x d}.
#' The simulated multivariate Pareto data.
#' \item \code{counter} Positive integer. The number of times needed to sweep
#' over the \code{d} variables to simulate \code{n} multivariate
#' observations.
#'
#' ## !!! add examples (define params and call function)
#' }
rmpareto <- function(n, model, d, par) {
stopifnot((d==round(d)) & (d>=1))
stopifnot((n==round(n)) & (n>=1))
stopifnot(model %in% c("HR", "logistic", "neglogistic", "dirichlet"))
if (model=="HR") {
stopifnot(is.matrix(par))
Gamma = par
stopifnot(nrow(Gamma) == d & ncol(Gamma) == d)
cov.mat <- Gamma2Sigma(Gamma, k=1, full=FALSE)
chol_mat <- matrix(0,d,d)
chol_mat[-1,-1] <- chol(cov.mat)
# !!! add error if cannot chol()
# !!! put here the trend and save it as a matrix (each row is one variable)
} else if (model=="logistic") {
stopifnot(length(par) == 1 & 1e-12 < par & par < 1 - 1e-12)
theta = par
} else if (model=="neglogistic") {
stopifnot(par > 1e-12)
theta = par
} else if (model=="dirichlet") {
alpha = par
stopifnot(length(alpha) == d)
stopifnot(all(alpha>1e-12))
} else if (model == "dirichlet_mix"){ # !!!
# !!!
}
counter <- 0
res <- numeric(0)
n.total <- 0
while (n.total < n){
counter <- counter + 1
shift <- sample(1:d, n, replace=TRUE)
for(k in 1:d){
if (model == "HR") {
trend <- sapply(1:d, function(j) Gamma[j,k]/2)
}
n.k <- sum(shift==k)
if(n.k>0){
proc <-
switch(model,
"HR" = simu_px_HR(n = n.k, idx = k, d = d,
trend = trend, chol_mat = chol_mat),
"logistic" = simu_px_logistic(n = n.k, idx=k, d=d, theta=theta),
"neglogistic"  = simu_px_neglogistic(n=n.k, idx=k, d=d, theta=theta),
"dirichlet"    = simu_px_dirichlet(n=n.k, idx=k, d=d, alpha=alpha),
"dirichlet_mix" = simu_px_dirichlet_mix(n = n.k,
idx = k, d = d,
weights=..., alpha=..., norm.alpha=...)
)
stopifnot(dim(proc)==c(n.k, d))
proc <- proc/rowSums(proc) / (1-runif(nrow(proc)))
idx.sim <- which(apply(proc,1,max) > 1)
res <- rbind(res, proc[idx.sim,])
n.total <- nrow(res)
}
}
}
return(list(res=res[sample(1:nrow(res), n, replace=FALSE),],
counter=counter))
}
rmpareto(1, "HR", 4, G)
devtools::load_all(".")
rmpareto(1, "HR", 4, G)
idx
proc
n <- 1
idx <- 3
d <- 4
weights <- c(.1, .1, .3, .5)
alpha <- c(2, 3, 1, 1.4)
weights <- c(0.1, .6, .3)
norm.alpha <- rbind(c(1, 2, 3), c(1, 1, 2), c(3, 1, 1), c(1, 1, 1))
#' Simulates Dirichlet mixture extremal functions
#'
#' Simulate Dirichlet mixture extremal functions
#'
#' @inheritParams simu_px_HR
#' @param theta Numeric vector  of size \code{d}.
#' @return Numeric matrix \eqn{n\times d}{n x d}. Simulated data.
### Internal: simulates Dirichlet mixture extremal functions
simu_px_dirichlet_mix <- function(n, idx, d, weights, alpha, norm.alpha) {
stopifnot(length(idx)==1 || length(idx)==n)
if (length(idx)==1) {
k <- sample(1:length(weights), n, replace=TRUE, prob=d*weights*norm.alpha[idx,])
} else {
k <- sapply(1:n, function(i) sample(1:length(weights), 1, prob=d*weights*norm.alpha[idx[i],]))
}
shape.mat <- alpha[,k,drop=FALSE]
shape.mat[cbind(idx,1:n)] <- shape.mat[cbind(idx,1:n)]+1
res <- t(matrix(rgamma(d*n, shape=shape.mat), nrow=d, ncol=n))
return(res/res[cbind(1:n,idx)])
}
simu_px_dirichlet_mix(n, idx = 1, 4, weights, alpha, norm.alpha)
is.infinite(3)
is.integer(3)
is.integer(3L)
G
G[, 1] <- rep(0, 4)
G
chol(cov.mat)
chol(G)
?tryCatch()
d <- 4
G
## 3. Non-decomposable graph
G = cbind(c(0,1.5,1.5,2), c(1.5,0,2,1.5), c(1.5,2,0,1.5), c(2,1.5,1.5,0))
trend <- sapply(1:d, function(j) Gamma[j,k]/2)
k <- 1
trend <- sapply(1:d, function(j) Gamma[j,k]/2)
trend <- sapply(1:d, function(j) Gamma[j,k]/2)
Gamma
Gamma <- G
trend <- sapply(1:d, function(j) Gamma[j,k]/2)
trend
n
# compute trend
trend <- sapply(1:d, function(k){
sapply(1:d, function(j) {
Gamma[j,k]/2)
}
})
?sapply
# compute trend
trend <- sapply(1:d, function(k){
sapply(1:d, function(j){
Gamma[j,k]/2
}
)
})
trend
k <- 1
sapply(1:d, function(j){
Gamma[j,k]/2
}
)
Gamma
Gamma[, 1] <- rep(0, 4)
sapply(1:d, function(j){
Gamma[j,k]/2
}
)
# compute trend
trend <- sapply(1:d, function(k){
sapply(1:d, function(j){
Gamma[j,k]/2
}
)
})
trend
sapply(1:d, function(j){
Gamma[j,k]/2
}
)
as.numeric(trend[1, ])
trend[1, ]
a <- trend[1, ]
# compute trend
trend <- t(sapply(1:d, function(k){
sapply(1:d, function(j){
Gamma[j,k]/2
}
)}))
trend
k <- 1
sapply(1:d, function(j){
Gamma[j,k]/2
}
)
d <- 4
k <- 4
sapply(1:d, function(j){
Gamma[j,k]/2
}
)
# compute trend
trend <- t(sapply(1:d, function(k){
sapply(1:d, function(j){
Gamma[j,k]/2
}
)}))
trend
stop("The elements of par must be greater than 1e-12,
when model = dirichlet.")
stop("The argument par must be scalar greater than 1e-12,
when model = neglogistic.")
stop("The argument par must be scalar greater than 1e-12,when model = neglogistic.")
stop("The argument par must be scalar greater than 1e-12,
when model = neglogistic.")
stop("The argument par must be a vector with d elements,
when model = dirichlet.")
stop("par must be a vector with d elements,
when model = dirichlet.")
rnorm(n = "a")
lintr::lint_package()
lintr::lint_package()
usethis::use_test("simulation_functions")
usethis::use_test("simulation_helpers")
# compute trend (matrix where each row is one variable)
trend <- t(sapply(1:d, function(k){
sapply(1:d, function(j){
Gamma[j, k] / 2
}
)}))
trend
Gamma <- G
# compute trend (matrix where each row is one variable)
trend <- t(sapply(1:d, function(k){
sapply(1:d, function(j){
Gamma[j, k] / 2
}
)}))
trend
cov_mat <- Gamma2Sigma(G)
cov_mat
cov_mat <- Gamma2Sigma(G, k = 1, full = FALSE)
cov_ma
cov-ma
cov_mat
cov_mat <- Gamma2Sigma(G, k = 3, full = FALSE)
chol_mat <- matrix(0, d, d)
chol_mat[-3, -3] <- chol(cov.mat)
chol_mat[-3, -3] <- chol(cov_mat)
chol_mat
expect_type(simu_px_HR(n, idx, d, trend, chol_mat), "matrix")
type(G)
typeof(G)
class(G)
sample(1:n)
sample(1:n, n)
n
# Define variables
n <- 7
sample(1:n, n)
res <- simu_px_logistic(n, sample(1:n, n), d, theta = 0.2)
### Internal: simulates logistic extremal functions
simu_px_logistic <- function(no.simu=1, idx, N, theta) {
stopifnot(length(idx)==1 || length(idx)==no.simu)
res       <- matrix(1/gamma(1-theta)*(-log(runif(no.simu*N)))^(-theta), nrow=no.simu, ncol=N)
res[cbind(1:no.simu,idx)] <- 1/gamma(1-theta)*rgamma(no.simu,shape=1-theta)^(-theta)
return(res/res[cbind(1:no.simu,idx)])
}
simu_px_logistic(1, 1, 3, .3)
simu_px_logistic(2, 1, 3, .3)
simu_px_logistic(2, c(1 ,2), 3, .3)
simu_px_logistic(2, c(1 ,2, 3), 3, .3)
simu_px_logistic(2, c(2, 1), 3, .3)
# Define variables
n <- 7
idx <- 2
d <- 4
trend <- c(0.75, 0.00, 1.00, 0.75)
G <-  cbind(c(0, 1.5, 1.5, 2),
c(1.5, 0, 2, 1.5),
c(1.5, 2, 0, 1.5),
c(2, 1.5, 1.5, 0))
cov_mat <- Gamma2Sigma(G, k = 3, full = FALSE)
chol_mat <- matrix(0, d, d)
chol_mat[-3, -3] <- chol(cov_mat)
res <- simu_px_logistic(n, sample(1:n, n), d, theta = 0.2)
res <- simu_px_logistic(n, c(1, 2), d, theta = 0.2)
n
res <- simu_px_logistic(n, c(1, 2, 2, 2, 2, 2, 2), d, theta = 0.2)
res <- simu_px_logistic(n, sample(1:n, size = n), d, theta = 0.2)
sample(1:n, size = n)
res <- simu_px_logistic(n, c(4, 6, 5, 7, 3, 1, 2), d, theta = 0.2)
n
res <- simu_px_logistic(n, 1:7, d, theta = 0.2)
res <- simu_px_logistic(n, 1:3, d, theta = 0.2)
res <- simu_px_logistic(n, c(1, 2), d, theta = 0.2)
res <- simu_px_logistic(n, c(1), d, theta = 0.2)
res <- simu_px_logistic(n, c(1, 2, 3, 4, 5, 6, 7), d, theta = 0.2)
debug(simu_px_logistic())
debug(simu_px_logistic
)
res <- simu_px_logistic(n, c(1, 2, 3, 4, 5, 6, 7), d, theta = 0.2)
no.simu
1/gamma(1-theta)*(-log(runif(no.simu*N)))^(-theta)
N
cbind(1:no.simu,idx)
1/gamma(1-theta)*rgamma(no.simu,shape=1-theta)^(-theta)
res <- simu_px_logistic(2, c(1, 2, 3), d, theta = 0.2)
res <- simu_px_logistic(2, c(1, 2), d, theta = 0.2)
cbind(1:no.simu,idx)
res
res <- simu_px_logistic(7, 1:7, d, theta = 0.2)
res
cbind(1:no.simu,idx)
1:no.simu
res <- simu_px_logistic(7, 1:7, d, theta = 0.2)
